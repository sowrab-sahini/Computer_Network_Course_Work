import csv
import sys
import os

######################################################################################################################################
# Information
######################################################################################################################################

# Author :
"""
    Name : Sowrab Sahini 
    Course : CSCE5580
    Project : OSPF link-state (LS) algorithm
    """

# Description :
"""
    The program accepts the network topology details in terms of the cost of links, and provides the shortest path tree for the
    network. It uses Dijkstra's Algorithm to construct its routing table.
"""

# Logic :


# Run Instructions :
"""
    Run the program by command : python lsp_project.py
"""

######################################################################################################################################
# Program Starts
######################################################################################################################################

# ----------------------------------------------------------------------------#
# Functions Implementation
# ----------------------------------------------------------------------------#

# Initialization of all the variables.

router_matrix = []
matrix_set = 0
nodes = []
distances = {}
unvisited = {}
previous = {}
visited = {}
interface = {}
path = []
start = 0
end = 0
# Function to process the given input file.


def process_file(fname):
    global matrix_set
    global router_matrix
    matrix_set = 0
    router_matrix = []
    f = open("input.txt", "r")
    print("File opened")
    router_matrix = [list(map(int, x.split(" "))) for x in f]  # Data from input file is stored in a two dimensional list(array).
    matrix_set = 1
    set_distances(router_matrix)


# Function to store the distances in dictionary format.


def set_distances(router_matrix):
    global distances
    global nodes

    distances = {}
    nodes = []

    num_nodes = len(router_matrix)

    for i in range(num_nodes):
        tempdict = {}
        for j in range(num_nodes):
            if i != j and router_matrix[i][j] != -1:
                tempdict[j + 1] = router_matrix[i][j]
        distances[i + 1] = tempdict
        nodes.append(i + 1)


def dijkstra(start):
    global distances
    global nodes
    global unvisited
    global previous
    global visited
    global interface

    # set the values to none for initialization.

    unvisited = {node: None for node in nodes}
    previous = {node: None for node in nodes}
    interface = {node: None for node in nodes}
    visited = {node: None for node in nodes}

    current = int(start)
    currentDist = 0
    unvisited[current] = currentDist

    while True:
        for next, distance in distances[current].items():

            if next not in unvisited: continue

            newDist = currentDist + distance

            if not unvisited[next] or unvisited[next] > newDist:
                unvisited[next] = newDist
                previous[next] = current

                if not interface[current]:
                    interface[next] = next
                else:
                    interface[next] = interface[current]

        visited[current] = currentDist
        del unvisited[current]

        done = 1
        for x in unvisited:
            if unvisited[x]:
                done = 0
                break
        if not unvisited or done:
            break

        elements = [node for node in unvisited.items() if node[1]]

        current, currentDist = sorted(elements, key=lambda x: x[1])[0]


# Function to generate the shortest path using the parent table generated by function dijkstra.


def shortest_path(start, end):
    global path

    path = []
    dest = int(end)
    src = int(start)
    path.append(dest)

    while dest != src:
        path.append(previous[dest])
        dest = previous[dest]

    path.reverse()


# ----------------------------------------------------------------------------#
# Actual Program Starts
# ----------------------------------------------------------------------------#
# Accept the topology file.
if matrix_set == 1:
    answer = input("\nThe network topology is already uploaded. Do you want to overwrite? (Y/N) :")

if matrix_set == 0 or answer == 'Y' or answer == 'y':
    print("Input File Name:")
    filename = input()
    try:
        process_file(str(filename))
        start = 0
        end = 0
    except IOError:
        print("\nThe file does not exist. Please try again..")

    # Accept the source router and display the connection table.

if matrix_set == 1:
    start = input("Select a source router : ")
    print(len(router_matrix))
    if int(start) > 0 and int(start) <= len(router_matrix):
        dijkstra(start)
    else:
        start = 0
        print("Please enter a valid source router.")
else:
    print("\nNo network topology matrix exist. Please upload the data file first.. ")

    # Accept the destination router and display the shortest path and cost.

if matrix_set == 1:
    end = 1
    while int(end) <= len(router_matrix):
        if 0 < int(end) <= len(router_matrix):
            if int(start) == 0:
                print("No source router selected yet. Please select a source router using choice : 2.")
            elif int(start) == int(end):
                print("%s ==> %s :" %(start,end))
                print("path cost: 0")
                print("path taken: %s" %(start))
            elif not previous[int(end)]:
                print("There does not exist any route from Source : %s to Destination : %s. \nPlease select a different destination router. " % (start, end))
            else:
                shortest_path(start, end)
                print("%s ==> %s : " %(start, end))
                print "path taken:",
                for item in path:
                    print str(item)+ "-->",
                    cost = 0
                    if visited[int(end)]:
                        cost = visited[int(end)]
                print "\npath cost : " + str(cost)
        end = end + 1
        pass
else:
    print("\nNo network topology matrix exist. Please upload the data file first.. ")
